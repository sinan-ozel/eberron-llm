

```python

class Agent:
    def call(self, agentB, q: str) -> Iterable:
        may_call = False
        for agent_type in self.may_call:
            if isinstance(agentB, agent_type):
                may_call = True
                break
        for c in agentB.respond(q):
            yield c

class AgentSubtypeA(Agent):
    pass



class AgentSubtypeB(Agent)
    may_call = [AgentSubtypeA]
```

Here is the critical appraoch:
An agent is just a text transformer:
```
class Agent:
    def respond(self, q: str) -> Iterable[str]
```



Actual code from the first attempt.

- [ ] Add the `call` function.
- [ ] Make `_retrieve` private
- [ ] Add a function called `_store`
- [ ] Add `vector_store` to the base class, may or may not be used.


```python
class Agent(ABC):
    """
    Abstract base class for an AI agent that interacts with a language model
    and retrieves information to respond to queries.
    """

    base_llm: BaseLLM
    """
    The base language model used by the agent. This model is responsible for
    generating responses and performing language processing tasks.
    """

    q_and_a: List[Tuple[str, str | Callable]]
    """
    A list of tuples, where each tuple contains:
        - A question (str).
        - The expected response, which can either be:
            - A string (str), or
            - A callable function (Callable) that returns the expected response as a string.
    Used for evaluating the agent's performance.
    """

    @abstractmethod
    def retrieve(self, q: str) -> List[Tuple[str, dict]]:
        """
        Retrieve relevant information for a given query.

        Args:
            q (str): The query string for which relevant data needs to be retrieved.

        Returns:
            List[Tuple[str, dict]]: A list of tuples where each tuple contains
            a relevant piece of information (e.g., a document or text snippet) as a string,
            and its associated metadata as a dictionary.
        """
        return []

    @abstractmethod
    def _prompt(self, q: str) -> str:
        """
        Generate a formatted prompt based on the given query.

        Args:
            q (str): The query string for which the prompt is generated.

        Returns:
            str: The formatted prompt that will be used for generating a response.
        """
        return ""

    @abstractmethod
    def respond(self, q: str) -> Iterable[str]:
        """
        Generate a response for the given query by retrieving information
        and interacting with the language model.

        Args:
            q (str): The query string for which the response is generated.

        Yields:
            Iterable[str]: An iterable of response strings generated by the agent.
        """
        while False:
            yield ""

    def evaluate(self) -> Tuple[float, np.ndarray]:
        """
        Evaluate the agent's performance by comparing its responses to a list of
        predefined question-answer pairs (`q_and_a`).

        This method iterates through the list of questions and their corresponding
        expected answers. For each question, the agent generates a response using
        the `respond` method. The response is compared to the expected answer
        (either a string or the output of a callable function) to determine correctness.

        Returns:
            Tuple[float, np.ndarray]: A tuple containing:
                - The accuracy as a float (correct answers / total questions), formatted to three decimal places.
                - A NumPy array (`np.ndarray`) where each element is 1 if the response matched the expected answer,
                  or 0 otherwise.

        Example:
            If `q_and_a` contains 10 questions and the agent answers 7 correctly,
            and their correctness is stored in a NumPy array, this method will return `(0.700, array([1, 1, 0, ...]))`.
        """
        matches = np.zeros(len(self.q_and_a))
        i = 0
        for q, expected_response in self.q_and_a:
            if isinstance(expected_response, str):
                if ''.join([r for r in self.respond(q)]).strip() == expected_response.strip():
                    matches[i] = 1
            else:
                if ''.join([r for r in self.respond(q)]).strip() == expected_response().strip():
                    matches[i] = 1
            i += 1

        return f'{matches.sum() / len(matches):.03f}', matches
```

